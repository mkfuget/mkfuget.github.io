---
layout: post
title:      "Software Engineering and Problem Solving"
date:       2020-12-17 03:17:33 +0000
permalink:  software_engineering_and_problem_solving
---


While engineering, science and math are often correlated as a larger subset of fields there are some fundamental differences that are think are useful to discuss when thinking about our work process as software engineers. Math is a field is based on finding solutions, given a problem and a set of existing definitions how can we prove a new theorem. If that is done the proof will always be true given the set of previous proofs that were used to develop it. Similarly science generally deals with devloping theories about how the physical world works, and what effect will happen as a result of any particular action. 

In contrast, engineering is focused on providing products and services by making the best use of resources available. When designing a plane you will generally have a set of cost and performance benchmarks to reach to guide your design, however there is no correct answer as to what the design of the plane should be given the requirements you are trying to meet. There are a number of different tradeoffs that can be made and every decision is balancing the potential cost and performance of the product.

# Applying to Software Engineering

All of this applied to producing, developing and maintaining software products as well as what are thought of as more traditional engineering products like planes and  cars. In addition I think the traditional software engineering education and interview process has caused people to treat development as finding answers to problems by choosing what algorithm they can use to pass all of their tests in the shortest amount of time. While this is certainlya vital portion of analysis when developing software, it is not the only one and it is important to not get tunnel visioned on one metric when building products. If you have an idea that might decrease the time a particular process in your program takes to run, before implementing it you should also consider the cost and time it takes to develop, potential increased complexity of the code and the potential that the change could endanger meeting set deadlines.
